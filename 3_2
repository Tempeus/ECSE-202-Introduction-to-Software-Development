/**
 * Implements a Binary tree class
 * @author Kevin
 *
 */

public class bTree {
	public static int NBalls = 0;
	bNode root = null;					// Default constructor
	
/**
 * addNode method - wrapper for rNode
 */	
	public void addNode(gBall iBall) {		// This is a wrapper to hide
		root = rNode(root, iBall);			// having to deal with root node.
	}									// Calls actual method below.
/**
 * rNode method - recursively adds a new entry into the B-Tree
 */	
	private bNode rNode(bNode root, gBall iBall) {
//
//  Termination condition for recursion.  We have descended to a leaf
//  node of the tree (or the tree may initially be empty).  In either case,
//	create a new node --> copy over data, set successor nodes to null.
//
		if (root == null) {
			bNode node = new bNode();	// Create a new node
			node.iBall = iBall;			// Copy data
			node.left = null;			// Successors to null.
			node.right = null;
			root = node;					// Node created is root
			return root;				// of new (sub) tree.
		}
//
//	Not at a leaf node, so traverse to the left if data being
//  added is strictly less than data at current node.
//
		else if (iBall.bSize < root.iBall.bSize) {
			root.left = rNode(root.left,iBall);
		}
//
//  If greater than or equal, then traverse to the right.  Keep
//  recursing until a node is found with no successors.
		else {
			root.right = rNode(root.right,iBall);
		}
		return root;
	}
	
/**
 * inorder method - inorder traversal via call to recursive method
 */
	
	public void inorder() {			// This is a wrapper for traverse_
		traverse_inorder(root);		// inorder to hide details of the
	}								// root node.
	
/**
 * traverse_inorder method - recursively traverses tree in order and prints each node.
 * Order: Descend following left successor links, returning back to the current
 *        root node (where a specific action takes place, e.g., printing data),
 *        and then repeat the descent along right successor links.
 */
	
	private void traverse_inorder(bNode root) {
		if (root.left != null) traverse_inorder(root.left);
		System.out.println(root.iBall);
		if (root.right != null) traverse_inorder(root.right);
	}
	
	public boolean isRunning(gBall x) {
		if (x.bVel > 0) {
			return true;
		}
		else {
			return false;
		}
	}
	
	public void moveSort() {
		
	}
	
	public class bNode {
		gBall iBall;
		bNode left;
		bNode right;
	}
}
